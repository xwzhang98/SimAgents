"""
Code executor module for running Python code generated by agents.
Uses autogen's LocalCommandLineCodeExecutor for safe code execution.
"""

import os
import tempfile
from typing import Optional, Dict, Any
from autogen import ConversableAgent
from autogen.coding import LocalCommandLineCodeExecutor


class CodeExecutor:
    """Manages code execution for visualization and analysis agents."""
    
    def __init__(
        self,
        work_dir: Optional[str] = None,
        timeout: int = 300,
        human_input_mode: str = "NEVER"
    ):
        """
        Initialize code executor.
        
        Args:
            work_dir: Working directory for code execution (if None, creates temp dir)
            timeout: Execution timeout in seconds (default 5 minutes)
            human_input_mode: Human input mode for executor agent
        """
        self.work_dir = work_dir or tempfile.mkdtemp(prefix="simagents_exec_")
        self.timeout = timeout
        self.human_input_mode = human_input_mode
        
        # Create the executor
        self._executor = LocalCommandLineCodeExecutor(
            timeout=timeout,
            work_dir=self.work_dir,
        )
        
        # Create executor agent
        self._executor_agent = ConversableAgent(
            name="code_executor_agent",
            llm_config=False,  # No LLM needed for executor
            code_execution_config={"executor": self._executor},
            human_input_mode=human_input_mode,
            is_termination_msg=lambda x: x.get("content", "").rstrip().endswith("TERMINATE"),
        )
        
        print(f"✅ Code executor initialized with work_dir: {self.work_dir}")
    
    def execute_code(self, code: str, language: str = "python") -> Dict[str, Any]:
        """
        Execute code and return results.
        
        Args:
            code: Code to execute
            language: Programming language (default: python)
            
        Returns:
            Dict with execution results including output and exit code
        """
        # Create a message with code block
        message = f"```{language}\n{code}\n```"
        
        # Execute through the agent
        result = self._executor_agent.generate_reply(
            messages=[{"role": "user", "content": message}]
        )
        
        return {
            "output": result,
            "work_dir": self.work_dir,
            "success": True if result else False
        }
    
    def execute_with_agent(self, agent, message: str) -> Any:
        """
        Execute code generated by an agent.
        
        Args:
            agent: Agent that generates code
            message: Message to send to the agent
            
        Returns:
            Chat result from the execution
        """
        return self._executor_agent.initiate_chat(agent, message=message)
    
    def save_and_execute_script(self, code: str, filename: str = "script.py") -> Dict[str, Any]:
        """
        Save code to a file and execute it.
        
        Args:
            code: Python code to save and execute
            filename: Name of the script file
            
        Returns:
            Dict with execution results
        """
        script_path = os.path.join(self.work_dir, filename)
        
        # Save the script
        with open(script_path, 'w') as f:
            f.write(code)
        
        print(f"💾 Saved script: {script_path}")
        
        # Execute the script
        result = self.execute_code(f"python {filename}")
        result["script_path"] = script_path
        
        return result
    
    def get_work_dir(self) -> str:
        """Get the working directory path."""
        return self.work_dir
    
    def get_executor_agent(self) -> ConversableAgent:
        """Get the executor agent for direct use with other agents."""
        return self._executor_agent
    
    def cleanup(self):
        """Clean up temporary files if using temp directory."""
        if self.work_dir.startswith(tempfile.gettempdir()):
            import shutil
            try:
                shutil.rmtree(self.work_dir)
                print(f"🧹 Cleaned up temporary directory: {self.work_dir}")
            except Exception as e:
                print(f"⚠️ Warning: Failed to clean up {self.work_dir}: {e}")


class SharedCodeExecutor:
    """Singleton code executor that can be shared across agents."""
    
    _instance = None
    _executor = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    @classmethod
    def get_executor(cls, work_dir: Optional[str] = None, **kwargs) -> CodeExecutor:
        """
        Get or create the shared code executor.
        
        Args:
            work_dir: Working directory (if None, uses default)
            **kwargs: Additional arguments for CodeExecutor
            
        Returns:
            Shared CodeExecutor instance
        """
        if cls._executor is None:
            cls._executor = CodeExecutor(work_dir=work_dir, **kwargs)
        return cls._executor
    
    @classmethod
    def reset(cls):
        """Reset the shared executor (useful for testing)."""
        if cls._executor:
            cls._executor.cleanup()
        cls._executor = None